
/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_LT
%token TOKEN_GT
%token TOKEN_OR
%token TOKEN_AND
%token TOKEN_NOT
%token TOKEN_COMMA
%token TOKEN_COMMENT
%token TOKEN_LBRACK
%token TOKEN_RBRACK
%token TOKEN_LCURLY
%token TOKEN_RCURLY
%token TOKEN_CARAT
%token TOKEN_MULTIPLY
%token TOKEN_DIVIDE
%token TOKEN_MODULO
%token TOKEN_SINGLE_LINE
%token TOKEN_LPAREN
%token TOKEN_RPAREN
%token TOKEN_WHITESPACE
%token TOKEN_LE
%token TOKEN_GE
%token TOKEN_NOT_EQUAL
%token TOKEN_EQUAL
%token TOKEN_EQUIVALENT
%token TOKEN_COLON
%token TOKEN_SEMI
%token TOKEN_ADD
%token TOKEN_SUBTRACT
%token TOKEN_INCREMENT
%token TOKEN_DECREMENT
%token TOKEN_WHILE
%token TOKEN_VOID
%token TOKEN_FALSE
%token TOKEN_TRUE
%token TOKEN_RETURN
%token TOKEN_PRINT
%token TOKEN_FUNCTION
%token TOKEN_FOR
%token TOKEN_IF
%token TOKEN_ELSE
%token TOKEN_ARRAY
%token TOKEN_STRING
%token TOKEN_INTEGER
%token TOKEN_BOOLEAN
%token TOKEN_CHAR
%token TOKEN_BACKLASH
%token TOKEN_DIGITS
%token TOKEN_LETTER
%token TOKEN_IDENTIFIER
%token TOKEN_STRING_LITERAL
%token TOKEN_CHAR_LITERAL
%token TOKEN_ERROR

%union {

    struct decl         *decl;
    struct stmt         *stmt;
    struct expr         *expr;
    struct param_list   *param_list;
    struct symbol       *symbol;
    struct type         *type;
    char                *name;
};

%type <decl> program decl_list decl
%type <stmt> stmt stmt_list stmt_regular stmt_no_inner 
%type <expr> expr expr_list expr_assign expr_or expr_and expr_comp expr_as expr_md expr_expo expr_neg expr_preIncr expr_posIncr expr_group expr_values expr_bool expr_opt array_elements
%type <type> type type2
%type <param_list> param_list param_list_n param
/*%type <symbol> ident*/
%type <name> ident

%{

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "decl.h"
#include "stmt.h"
#include "expr.h"
#include "type.h"
#include "symbol.h"
#include "param_list.h"
#include "functions.c"
#include <string.h>
/*#define YYSTYPE struct expr * */

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

struct decl *parser_result;


%}

%%

/* Here is the grammar: program is the start symbol. */

program     : decl_list
                { parser_result = $1; return 0; }
            ;

decl_list   : decl decl_list
                { $1->next = $2; $$ = $1; }
            |  
                { $$ = 0; }
            ;

decl        : ident TOKEN_COLON type TOKEN_SEMI
	            { $$ = decl_create($1, $3, 0, 0, 0, 0); }
            | ident TOKEN_COLON type TOKEN_EQUAL expr TOKEN_SEMI
    	        { $$ = decl_create($1, $3, $5, 0, 0, 0); }
            | ident TOKEN_COLON type TOKEN_EQUAL TOKEN_LCURLY stmt_list TOKEN_RCURLY
                { $$ = decl_create($1, $3, 0, $6, 0, 0); }
            | ident TOKEN_COLON type TOKEN_EQUAL TOKEN_LCURLY TOKEN_RCURLY
                { $$ = decl_create($1, $3, 0, 0, 0, 1); }
            | ident TOKEN_COLON TOKEN_ARRAY TOKEN_LBRACK TOKEN_RBRACK type2 TOKEN_EQUAL expr TOKEN_SEMI
                { $$ = decl_create($1, $6, $8, 0, 0, 0); }
            ;

stmt        : stmt_no_inner
                { $$ = $1; }
            | stmt_regular
                { $$ = $1; }
            ;

stmt_regular: TOKEN_IF TOKEN_LPAREN expr TOKEN_RPAREN stmt_regular TOKEN_ELSE stmt_regular
                { $$ = stmt_create(STMT_IF_ELSE, 0, 0, $3, 0, $5, $7); }
            | TOKEN_LCURLY stmt_list TOKEN_RCURLY
                { $$ = stmt_create(STMT_BLOCK, 0, 0, 0, 0, $2, 0); }
            | expr TOKEN_SEMI
                { $$ = stmt_create(STMT_EXPR, 0, 0, $1, 0, 0, 0); }
            | TOKEN_PRINT expr_list TOKEN_SEMI
                { $$ = stmt_create(STMT_PRINT, 0, 0, $2, 0, 0, 0); }
            | TOKEN_PRINT TOKEN_SEMI 
                { $$ = stmt_create(STMT_PRINT, 0, 0, 0, 0, 0, 0); }
            | TOKEN_FOR TOKEN_LPAREN expr_opt TOKEN_SEMI expr_opt TOKEN_SEMI expr_opt TOKEN_RPAREN stmt_regular 
                { $$ = stmt_create(STMT_FOR, 0, $3, $5, $7, $9, 0); }
            | TOKEN_RETURN expr_opt TOKEN_SEMI
                { $$ = stmt_create(STMT_RETURN, 0, $2, 0, 0, 0, 0); }
            | decl
                { $$ = stmt_create(STMT_DECL, $1, 0, 0, 0, 0, 0); }
            ;

stmt_no_inner: TOKEN_IF TOKEN_LPAREN expr TOKEN_RPAREN stmt
                { $$ = stmt_create(STMT_IF_ELSE, 0, 0, $3, 0, $5, 0); }
             | TOKEN_IF TOKEN_LPAREN expr TOKEN_RPAREN stmt_regular TOKEN_ELSE stmt_no_inner
                { $$ = stmt_create(STMT_IF_ELSE, 0, 0, $3, 0, $5, $7); } 
            ;

stmt_list   : stmt stmt_list 
                { $1->next = $2; $$ = $1; }
            | stmt
                { $$ = $1; }
            ;

expr_list   : expr
                { $$ = $1; }
            | expr TOKEN_COMMA expr_list
                { $$ = expr_create(EXPR_COMMA, $1, $3); }
            ;

expr	    : expr_assign
                { $$ = $1; }
	        ;

expr_assign : ident TOKEN_EQUAL expr_assign
                { $$ = expr_create(EXPR_EQUAL, expr_create_name($1), $3); }
            // | expr_array TOKEN_EQUAL expr_assign
            //     { $$ = expr_create(EXPR_EQUAL, $1, $3); }
            | expr_or
                { $$ = $1; }
            ;

expr_or     : expr_or TOKEN_OR expr_and
                { $$ = expr_create(EXPR_OR, $1, $3); }
            | expr_and
                { $$ = $1; }
            ;

expr_and    : expr_and TOKEN_AND expr_comp
                { $$ = expr_create(EXPR_AND, $1, $3); }
            | expr_comp
                { $$ = $1; }
            ;

expr_comp   : expr_comp TOKEN_GT expr_as
                { $$ = expr_create(EXPR_GT, $1, $3); }
            | expr_comp TOKEN_LT expr_as
                { $$ = expr_create(EXPR_LT, $1, $3); }
            | expr_comp TOKEN_EQUIVALENT expr_as
                { $$ = expr_create(EXPR_EQUIV, $1, $3); }
            | expr_comp TOKEN_NOT_EQUAL expr_as
                { $$ = expr_create(EXPR_NOT_EQUAL, $1, $3); }
            | expr_comp TOKEN_GE expr_as
                { $$ = expr_create(EXPR_GE, $1, $3); }
            | expr_comp TOKEN_LE expr_as
                { $$ = expr_create(EXPR_LE, $1, $3); }
            | expr_as
                { $$ = $1; }
            ;

expr_as     : expr_as TOKEN_ADD expr_md
                { $$ = expr_create(EXPR_ADD, $1, $3); }
            | expr_as TOKEN_SUBTRACT expr_md
                { $$ = expr_create(EXPR_SUB, $1, $3); }
            | expr_md
                { $$ = $1; }
            ;

expr_md     : expr_md TOKEN_MULTIPLY expr_expo
                 { $$ = expr_create(EXPR_MULT, $1, $3); } 
            | expr_md TOKEN_DIVIDE expr_expo
                 { $$ = expr_create(EXPR_DIVIDE, $1, $3); } 
            | expr_expo
                { $$ = $1; }
            | expr_md TOKEN_MODULO expr_expo
                { $$ = expr_create(EXPR_MOD, $1, $3); }
            ;

expr_expo   : expr_expo TOKEN_CARAT expr_neg
                { $$ = expr_create(EXPR_CARAT, $1, $3); }
            | expr_neg
                { $$ = $1; }
            ;

expr_neg    : TOKEN_SUBTRACT expr_neg
                { $$ = expr_create(EXPR_NEG, 0, $2); }
            | TOKEN_NOT expr_neg
                { $$ = expr_create(EXPR_NOT, 0, $2); }
            | expr_preIncr
                { $$ = $1; }
            ;

expr_preIncr: TOKEN_INCREMENT expr_posIncr
                { $$ = expr_create(EXPR_PRE_INCREMENT, 0, $2); }
            | TOKEN_DECREMENT expr_posIncr
                { $$ = expr_create(EXPR_PRE_DECREMENT, 0, $2); }
            | expr_posIncr
                { $$ = $1; }
            ;

expr_posIncr: expr_group TOKEN_INCREMENT 
                { $$ = expr_create(EXPR_POST_INCREMENT, $1, 0); }
            | expr_group TOKEN_DECREMENT 
                { $$ = expr_create(EXPR_POST_DECREMENT, $1, 0); }
            | expr_group
                { $$ = $1; }
            ;

expr_group  : TOKEN_LPAREN expr TOKEN_RPAREN
                { $$ = expr_create(EXPR_GROUP, 0, $2); }
            | ident TOKEN_LPAREN TOKEN_RPAREN
                { $$ = expr_create(EXPR_FUNCTION, expr_create_name($1), 0); }
            | ident TOKEN_LPAREN expr_list TOKEN_RPAREN
                { $$ = expr_create(EXPR_FUNCTION, expr_create_name($1), $3); }
            | TOKEN_LCURLY expr_list TOKEN_RCURLY
                { $$ = expr_create(EXPR_ARRAY_LITERAL, $2, 0); }
            | TOKEN_LBRACK expr TOKEN_RBRACK
                { $$ = $2; }
            | expr_values
                { $$ = $1; }
            ;

expr_values : TOKEN_CHAR_LITERAL
                { 
                    char *txt = replaceEscChars(yytext);
                    $$ = expr_create_character_literal(txt[1]);
                 }
            | TOKEN_DIGITS
                {
                    $$ = expr_create_integer_literal(atoi(yytext)); 
                }
            | TOKEN_STRING_LITERAL
                { 
                    char * txt;
                    txt = (char *)malloc(515); 
                    strcpy(txt, yytext);
                    $$ = expr_create_string_literal(txt);
                }
            | ident 
                { $$ = expr_create_name($1); }
            | ident TOKEN_LBRACK expr TOKEN_RBRACK array_elements
                {$$ = expr_create(EXPR_ARRAY_IDENT,expr_create_name($1),expr_create(EXPR_ARRAY_ELEMENT,$3,$5));}
            | expr_bool
                {$$ = $1; }
            ;

expr_bool   : TOKEN_TRUE
                { $$ = expr_create_boolean_literal(1); }
            | TOKEN_FALSE
                { $$ = expr_create_boolean_literal(0); }
            ;

expr_opt    : expr
                { $$ = $1; }
            | 
                { $$ = 0; }
            ;

type        : TOKEN_INTEGER
                { $$ = type_create(TYPE_INTEGER, 0, 0, 0); }
            | TOKEN_CHAR
                { $$ = type_create(TYPE_CHARACTER, 0, 0, 0); } 
            | TOKEN_STRING
                { $$ = type_create(TYPE_STRING, 0, 0, 0); } 
            | TOKEN_ARRAY TOKEN_LBRACK expr TOKEN_RBRACK type
                { $$ = type_create(TYPE_ARRAY, $3, 0, $5); } 
            | TOKEN_BOOLEAN
                { $$ = type_create(TYPE_BOOLEAN, 0, 0, 0); } 
            | TOKEN_FUNCTION type2 TOKEN_LPAREN param_list TOKEN_RPAREN 
                { $$ = type_create(TYPE_FUNCTION, 0, $4, $2); } 
            | TOKEN_VOID
                { $$ = type_create(TYPE_VOID, 0, 0, 0); } 
            ;

type2       : TOKEN_INTEGER
                { $$ = type_create(TYPE_INTEGER, 0, 0, 0); }
            | TOKEN_CHAR
                { $$ = type_create(TYPE_CHARACTER, 0, 0, 0); } 
            | TOKEN_STRING
                { $$ = type_create(TYPE_STRING, 0, 0, 0); } 
            | TOKEN_ARRAY TOKEN_LBRACK expr_opt TOKEN_RBRACK type2
                { $$ = type_create(TYPE_ARRAY, $3, 0, $5); } 
            | TOKEN_BOOLEAN
                { $$ = type_create(TYPE_BOOLEAN, 0, 0, 0); } 
            | TOKEN_FUNCTION type TOKEN_LPAREN param_list TOKEN_RPAREN 
                { $$ = type_create(TYPE_FUNCTION, 0, $4, $2); } 
            | TOKEN_VOID
                { $$ = type_create(TYPE_VOID, 0, 0, 0); } 
            ;

param_list  : param_list_n
                { $$ = $1; }
            |
                { $$ = 0; }
            ;

array_elements: TOKEN_LBRACK expr TOKEN_RBRACK array_elements
            {$$ = expr_create(EXPR_ARRAY_ELEMENT,$2,$4);}
            |
                { $$ = 0; }
            ;

param_list_n: param TOKEN_COMMA param_list_n
                { $1->next = $3; $$ = $1; }
            | param
                { $$ = $1; }
            ;

param       : ident TOKEN_COLON type
                { $$ = param_list_create($1, $3, 0); }
            ;

ident       : TOKEN_IDENTIFIER
                { 
                    char *txt;
                    txt = (char *)malloc(sizeof(yytext));
                    strcpy(txt, yytext);
                    $$ = txt;
                }
            ;
%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s\n",str);
    return 1;
}
